[
{
	"uri": "//localhost:1313/vi/1-introduce/",
	"title": "Gi·ªõi thi·ªáu",
	"tags": [],
	"description": "",
	"content": "B√†i vi·∫øt s·∫Ω h∆∞·ªõng d·∫´n b·∫°n x√¢y d·ª±ng m·ªôt pipeline CI/CD hi·ªáu qu·∫£ ƒë·ªÉ tri·ªÉn khai m·ªôt website vi·∫øt b·∫±ng ReactJS. Cho d√π b·∫°n l√† m·ªôt nh√† ph√°t tri·ªÉn t√¨m ki·∫øm t√≠nh t·ª± ƒë·ªông h√≥a, hay m·ªôt k·ªπ s∆∞ ƒë√°m m√¢y ƒëang thi·∫øt k·∫ø gi·∫£i ph√°p CI/CD, vi·ªác k·∫øt h·ª£p c√°c d·ªãch v·ª• AWS v√† GitLab s·∫Ω gi√∫p qu√° tr√¨nh ph√°t tri·ªÉn hi·ªáu qu·∫£ v√† ƒë√°ng tin c·∫≠y h∆°n nhi·ªÅu.\n"
},
{
	"uri": "//localhost:1313/vi/",
	"title": "X√¢y d·ª±ng Pipeline CI/CD cho D·ª± √°n ReactJS tr√™n GitLab b·∫±ng D·ªãch v·ª• AWS (ECR, Fargate, EC2)",
	"tags": [],
	"description": "",
	"content": "CI/CD Pipeline cho D·ª± √°n ReactJS s·ª≠ d·ª•ng D·ªãch v·ª• AWS T·ªïng quan Ho√†n th√†nh workshop, b·∫°n s·∫Ω c√≥ kh·∫£ nƒÉng thi·∫øt l·∫≠p m·ªôt pipeline CI/CD cho d·ª± √°n ReactJS c·ªßa m√¨nh tr√™n GitLab. Ki·∫øn tr√∫c c·ªßa pipeline kh√° ƒë∆°n gi·∫£n, t·∫≠p trung v√†o vi·ªác s·ª≠ d·ª•ng c√°c d·ªãch v·ª• ph·ªï bi·∫øn c·ªßa AWS nh∆∞ EC2, ECR v√† ECS. N·∫øu b·∫°n quan t√¢m ƒë·∫øn vi·ªác t√¨m hi·ªÉu th√™m v·ªÅ CI/CD, ƒë√¢y l√† m·ªôt c∆° h·ªôi tuy·ªát v·ªùi.\nB·∫Øt tay v√†o l√†m th√¥i! üöÄ\nN·ªôi dung Gi·ªõi thi·ªáu Ki·∫øn tr√∫c Thi·∫øt l·∫≠p ban ƒë·∫ßu C√†i ƒë·∫∑t ch√≠nh D·ªçn d·∫πp t√†i nguy√™n "
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.1-whatiscicd/",
	"title": "CI/CD l√† g√¨?",
	"tags": [],
	"description": "",
	"content": "CICD l√† g√¨? CI/CD Pipeline l√† m·ªôt chu·ªói c√°c giai ƒëo·∫°n t·ª± ƒë·ªông chuy·ªÉn ƒë·ªïi m√£ ngu·ªìn c·ªßa b·∫°n th√†nh m·ªôt website ƒëang ch·∫°y.\na. T√≠ch h·ª£p li√™n t·ª•c (CI - Continuous Integration) Thay ƒë·ªïi m√£ ngu·ªìn ƒë∆∞·ª£c t·ª± ƒë·ªông k√©o t·ª´ repository Git c·ªßa b·∫°n. C√°c b√†i ki·ªÉm tra ƒë∆°n v·ªã (unit test), ki·ªÉm tra ch·∫•t l∆∞·ª£ng m√£ (code quality check) v√† ki·ªÉm tra t√≠ch h·ª£p (integration test) ƒë∆∞·ª£c th·ª±c hi·ªán. N·∫øu th√†nh c√¥ng, m√£ ngu·ªìn ƒë∆∞·ª£c x√¢y d·ª±ng th√†nh m·ªôt s·∫£n ph·∫©m tri·ªÉn khai (deployable artifact). b. Ph√°t h√†nh li√™n t·ª•c (CD - Continuous Delivery) S·∫£n ph·∫©m tri·ªÉn khai ƒë∆∞·ª£c tri·ªÉn khai ƒë·∫øn m√¥i tr∆∞·ªùng staging ƒë·ªÉ ki·ªÉm tra th·ªß c√¥ng v√† ph√™ duy·ªát. Sau khi ƒë∆∞·ª£c ph√™ duy·ªát, s·∫£n ph·∫©m tri·ªÉn khai ƒë∆∞·ª£c tri·ªÉn khai ƒë·∫øn m√¥i tr∆∞·ªùng s·∫£n xu·∫•t (production). Ki·ªÉm tra hi·ªáu su·∫•t v√† ho·∫°t ƒë·ªông ƒë∆∞·ª£c th·ª±c hi·ªán li√™n t·ª•c. "
},
{
	"uri": "//localhost:1313/vi/1-introduce/1.2-benefitofcicd/",
	"title": "L·ª£i √≠ch c·ªßa CI/CD",
	"tags": [],
	"description": "",
	"content": "L·ª£i √≠ch c·ªßa CI/CD H√£y t∆∞·ªüng t∆∞·ª£ng m·ªôt ·ª©ng d·ª•ng m·∫°ng x√£ h·ªôi ph·ªï bi·∫øn ƒë·ªôt ng·ªôt c√≥ l∆∞·ª£ng ng∆∞·ªùi d√πng tƒÉng v·ªçt. N·∫øu kh√¥ng c√≥ CI/CD, vi·ªác m·ªü r·ªông quy m√¥ ·ª©ng d·ª•ng ƒë·ªÉ th√≠ch ·ª©ng v·ªõi l∆∞u l∆∞·ª£ng truy c·∫≠p tƒÉng cao s·∫Ω li√™n quan ƒë·∫øn vi·ªác ch·ªânh s·ª≠a m√£ ngu·ªìn th·ªß c√¥ng, ki·ªÉm tra v√† tri·ªÉn khai - m·ªôt qu√° tr√¨nh ch·∫≠m ch·∫°p v√† d·ªÖ x·∫£y ra l·ªói. CI/CD t·ª± ƒë·ªông h√≥a quy tr√¨nh n√†y, cho ph√©p ·ª©ng d·ª•ng m·ªü r·ªông quy m√¥ m·ªôt c√°ch li·ªÅn m·∫°ch v√† duy tr√¨ kh·∫£ nƒÉng ph·∫£n h·ªìi v·ªõi nhu c·∫ßu c·ªßa ng∆∞·ªùi d√πng.\nD∆∞·ªõi ƒë√¢y l√† m·ªôt s·ªë l·ª£i √≠ch ch√≠nh c·ªßa CI/CD:\nGi·∫£m th·ªùi gian v√† c√¥ng s·ª©c: T·ª± ƒë·ªông h√≥a vi·ªác x√¢y d·ª±ng, ki·ªÉm th·ª≠ v√† tri·ªÉn khai, gi√∫p ti·∫øt ki·ªám th·ªùi gian ph√°t tri·ªÉn qu√Ω gi√°.\nC·∫£i thi·ªán ch·∫•t l∆∞·ª£ng: Ph√°t hi·ªán v√† s·ª≠a l·ªói s·ªõm trong chu k·ª≥ ph√°t tri·ªÉn th√¥ng qua c√°c b√†i ki·ªÉm tra t·ª± ƒë·ªông.\nC·∫≠p nh·∫≠t nhanh h∆°n: Cung c·∫•p c√°c t√≠nh nƒÉng m·ªõi v√† b·∫£n s·ª≠a l·ªói cho ng∆∞·ªùi d√πng nhanh ch√≥ng v√† hi·ªáu qu·∫£.\nN√¢ng cao b·∫£o m·∫≠t: T·ª± ƒë·ªông h√≥a qu√©t b·∫£o m·∫≠t ƒë·ªÉ x√°c ƒë·ªãnh v√† kh·∫Øc ph·ª•c l·ªó h·ªïng s·ªõm.\nC·∫£i thi·ªán h·ª£p t√°c trong c√¥ng vi·ªác: Th√∫c ƒë·∫©y quy tr√¨nh l√†m vi·ªác hi·ªáu qu·∫£ cho c√°c nh√≥m ph√°t tri·ªÉn.\nH√£y s·∫µn s√†ng ƒë·ªÉ kh√°m ph√° th·∫ø gi·ªõi th√∫ v·ªã c·ªßa CI/CD cho trang web ReactJS c·ªßa b·∫°n!\n"
},
{
	"uri": "//localhost:1313/vi/2-architecture/",
	"title": "Ki·∫øn tr√∫c",
	"tags": [],
	"description": "",
	"content": "Ki·∫øn tr√∫c H√£y c√πng xem qua ki·∫øn tr√∫c c·ªßa ch√∫ng ta.\n"
},
{
	"uri": "//localhost:1313/vi/2-architecture/2.1-designsolution/",
	"title": "Thi·∫øt k·∫ø Gi·∫£i ph√°p CI/CD",
	"tags": [],
	"description": "",
	"content": "Thi·∫øt k·∫ø m·ªôt Gi·∫£i ph√°p CI/CD Ki·∫øn tr√∫c m√¥ t·∫£ quy tr√¨nh CI/CD cho d·ª± √°n c·ªßa b·∫°n ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n GitLab, CI/CD pipeline ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a th√¥ng qua file .gitlab-ci.yml.\nC√°c giai ƒëo·∫°n trong CI/CD pipeline: X√¢y d·ª±ng (Build): Giai ƒëo·∫°n n√†y t·∫≠p trung v√†o vi·ªác x√¢y d·ª±ng d·ª± √°n t·ª´ m√£ ngu·ªìn tr√™n GitLab. ƒê·∫©y (Push): Giai ƒëo·∫°n n√†y li√™n quan ƒë·∫øn vi·ªác t·∫°o container image d·ª±a tr√™n ƒë·∫ßu ra c·ªßa qu√° tr√¨nh build v√† ƒë·∫©y n√≥ v√†o Elastic Container Registry (ECR). Tri·ªÉn khai (Deploy): Giai ƒëo·∫°n n√†y c·∫≠p nh·∫≠t Elastic Container Service (ECS) service c·ªßa b·∫°n v·ªõi container image m·ªõi ƒë∆∞·ª£c t·∫°o t·ª´ ECR. M√¥i tr∆∞·ªùng th·ª±c thi c√¥ng vi·ªác: C√°c c√¥ng vi·ªác CI/CD s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán tr√™n m·ªôt m√°y ch·ªß Elastic Compute Cloud (EC2) ƒë√£ ƒëƒÉng k√Ω l√†m GitLab Runner. Thi·∫øt l·∫≠p n√†y cho ph√©p GitLab giao vi·ªác th·ª±c thi cho m√°y ch·ªß EC2.\nC√°ch ho·∫°t ƒë·ªông? Ng∆∞·ªùi d√πng commit m√£ v√†o repository GitLab. GitLab ph√°t hi·ªán c√°c thay ƒë·ªïi v√† ch·∫°y quy tr√¨nh CI/CD (quy tr√¨nh ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong t·ªáp .gitlab-ci.yml). GitLab Runner x√¢y d·ª±ng d·ª± √°n t·ª´ m√£ ngu·ªìn. Sau khi x√¢y d·ª±ng ho√†n t·∫•t, GitLab Runner t·∫°o container image v√† ƒë·∫©y image l√™n ECR. Sau khi image ƒë∆∞·ª£c ƒë·∫©y l√™n ECR, GitLab Runner ch·∫°y giai ƒëo·∫°n tri·ªÉn khai, c·∫≠p nh·∫≠t d·ªãch v·ª• ECS v·ªõi phi√™n b·∫£n m·ªõi nh·∫•t c·ªßa container image. D·ªãch v·ª• ho√†n th√†nh v√† phi√™n b·∫£n m·ªõi c·ªßa trang web ƒë∆∞·ª£c ph√°t h√†nh. "
},
{
	"uri": "//localhost:1313/vi/2-architecture/2.2-understandresources/",
	"title": "T√¨m hi·ªÉu v·ªÅ c√°c t√†i nguy√™n trong ki·∫øn tr√∫c n√†y",
	"tags": [],
	"description": "",
	"content": "Elastic Compute Cloud (EC2) D·ªãch v·ª• AWS n√†y cung c·∫•p c√°c m√°y ch·ªß ·∫£o c√≥ kh·∫£ nƒÉng m·ªü r·ªông (c√°c EC2 instances) tr√™n cloud. GitLab Runner c·ªßa b·∫°n s·∫Ω ƒë∆∞·ª£c c√†i ƒë·∫∑t tr√™n m·ªôt EC2 instance, cho ph√©p GitLab giao vi·ªác th·ª±c thi CI/CD.\nElastic Container Registry D·ªãch v·ª• AWS n√†y ho·∫°t ƒë·ªông nh∆∞ m·ªôt kho l∆∞u tr·ªØ an to√†n cho container image c·ªßa b·∫°n. B·∫°n s·∫Ω ƒë·∫©y container image ƒë∆∞·ª£c x√¢y d·ª±ng trong quy tr√¨nh CI/CD v√†o kho ECR c·ªßa b·∫°n.\nElastic Container Service D·ªãch v·ª• AWS n√†y cung c·∫•p m·ªôt n·ªÅn t·∫£ng ƒë·ªÉ ch·∫°y v√† qu·∫£n l√Ω c√°c ·ª©ng d·ª•ng ƒë∆∞·ª£c ƒë√≥ng g√≥i trong container. B·∫°n s·∫Ω s·ª≠ d·ª•ng ECS ƒë·ªÉ tri·ªÉn khai ·ª©ng d·ª•ng web c·ªßa b·∫°n sau khi c·∫≠p nh·∫≠t v·ªõi container image m·ªõi ƒë∆∞·ª£c t·∫°o t·ª´ ECR.\nGitLab N·ªÅn t·∫£ng n√†y l√† h·ªá th·ªëng qu·∫£n l√Ω phi√™n b·∫£n m√£ ngu·ªìn cho d·ª± √°n c·ªßa b·∫°n. N√≥ l∆∞u tr·ªØ m·ªôt c√°ch an to√†n m√£ ngu·ªìn c·ªßa b·∫°n v√† theo d√µi c√°c thay ƒë·ªïi theo th·ªùi gian.\n.gitlab-ci.yml T·ªáp YAML n√†y x√°c ƒë·ªãnh c√°c giai ƒëo·∫°n v√† nhi·ªám v·ª• c·ª• th·ªÉ trong quy tr√¨nh CI/CD c·ªßa b·∫°n, ch·ªâ ƒë·ªãnh c√°c h√†nh ƒë·ªông c·∫ßn th·ª±c hi·ªán ·ªü m·ªói giai ƒëo·∫°n.\n"
},
{
	"uri": "//localhost:1313/vi/3-prerequisites/",
	"title": "Thi·∫øt l·∫≠p ban ƒë·∫ßu",
	"tags": [],
	"description": "",
	"content": "Thi·∫øt l·∫≠p ban ƒë·∫ßu B·∫°n c·∫ßn m·ªôt Virtual Private Cloud (VPC) ƒë·ªÉ ch·∫°y c√°c d·ªãch v·ª• AWS b√™n trong n√≥. Vi·ªác ƒë·∫∑t c√°c d·ªãch v·ª• c·ªßa b·∫°n b√™n trong VPC s·∫Ω ƒë·∫£m b·∫£o t√≠nh b·∫£o m·∫≠t, ƒë·ªìng th·ªùi b·∫°n c≈©ng c√≥ th·ªÉ th·ª±c hi·ªán c√°c ph∆∞∆°ng √°n nh∆∞ c√†i ƒë·∫∑t Security Group (SG) hay Network Access Control List (NACL) ƒë·ªÉ b·∫£o v·ªá c√°c t√†i nguy√™n c·ªßa m√¨nh.\nƒê·ªìng th·ªùi, m·ªôt s·ªë d·ªãch v·ª• nh∆∞ Elastic Compute Cloud (EC2), Elastic Container Service (ECS) s·∫Ω y√™u c·∫ßu b·∫°n ƒë·∫∑t nh·ªØng d·ªãch v·ª• n√†y v√†o trong 1 VPC.\nNote: T·∫•t nhi√™n b·∫°n c√≥ th·ªÉ x√†i VPC m·∫∑t ƒë·ªãnh, nh∆∞ng t√¥i khuy·∫øn kh√≠ch b·∫°n t·∫°o 1 VPC m·ªõi, b·ªüi v√¨ m·ªói VPC n√™n ch·ªâ ƒë∆∞·ª£c s·ª≠ d·ª•ng cho m·ªôt m·ª•c ƒë√≠ch ri√™ng (vi·ªác b·∫°n ƒë·∫∑t t·∫•t c·∫£ d·ªãch v·ª• c·ªßa m√¨nh v√†o trong VPC m·∫∑c ƒë·ªãnh s·∫Ω khi·∫øn cho vi·ªác qu·∫£n l√Ω VPC c·ªßa b·∫°n tr·ªü n√™n kh√≥ khƒÉn v·ªÅ sau n√†y).\n"
},
{
	"uri": "//localhost:1313/vi/3-prerequisites/3.1-createvpc/",
	"title": "T·∫°o VPC",
	"tags": [],
	"description": "",
	"content": "B∆∞·ªõc 1. Truy c·∫≠p VPC Dashboard Truy c·∫≠p VPC Dashboard th√¥ng qua ƒë∆∞·ªùng link n√†y : VPC Dashboard. Sau ƒë√≥ nh√°y chu·ªôt ch·ªçn Create VPC.\nStep 2. Ch·ªçn CIDR block ƒê·ªÉ ƒë∆°n gi·∫£n h∆°n trong qu√° tr√¨nh setup VPC, t√¥i khuy√™n b·∫°n n√™n ch·ªçn Resource to create l√† VPC and more. N√≥ ch·ª©a c√°c template c·∫ßn thi·∫øt cho 1 VPC ho√†n ch·ªânh nh∆∞ subnet, route table, internet gateway, endpoint,\u0026hellip; s·∫Ω gi√∫p cho b·∫°n t·∫°o VPC d·ªÖ d√†ng h∆°n nhi·ªÅu.\n"
},
{
	"uri": "//localhost:1313/vi/4-mainsettings/",
	"title": "Main Settings",
	"tags": [],
	"description": "",
	"content": "AWS Services Here is some AWS services you will use in your CI/CD pipeline: EC2, ECR, ECS\nGitLab Beside, my project now is on GitLab environment, and I need to set up the project before I can deploy its resources to AWS.\n"
},
{
	"uri": "//localhost:1313/vi/4-mainsettings/4.1-setupgitlabproject/",
	"title": "Setup GitLab Project",
	"tags": [],
	"description": "",
	"content": "Define CI/CD pipeline with .gitlab-ci.yml Specifies the base image used for all jobs in the pipeline. Here, it\u0026rsquo;s node:18-alpine, a lightweight Node.js 18 image based on Alpine Linux.\nimage: node:18-alpine Defines three stages for the pipeline: build, push, and deploy. Jobs will run sequentially within each stage, and stages can be configured to run in parallel.\nstages:\r- build\r- push\r- deploy Runs a sequence of commands before any job:\nInstalls Python 3 and its package manager pip using apk package manager. Creates a virtual environment for awscli using python3 -m venv. Activates the virtual environment and installs awscli for interacting with AWS. Configures AWS credentials using environment variables $AWS_ACCESS_KEY_ID and $AWS_SECRET_ACCESS_KEY. before_script:\r- apk add --no-cache python3 py3-pip\r- apk add --no-cache docker\r- python3 -m venv /tmp/awscli-venv\r- source /tmp/awscli-venv/bin/activate\r- pip install awscli\r- aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID\r- aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY Defines a job named build in the build stage:\nInstalls dependencies using yarn install. Runs CI=false yarn build to build the project, likely using a build tool like Webpack or Rollup. Setting CI=false will ignore warning in build step. Saves the built artifacts in the build directory for later use. build:\rstage: build\rscript:\r- yarn install\r- CI=false yarn build\rartifacts:\rpaths:\r- build/ Defines a job named push in the push stage:\nDepends on the successful completion of the build job (dependencies: - build). Uses a different image, docker:latest, which provides necessary tools for building and pushing Docker images. Uses a Docker service (docker:dind) to run Docker commands within the job itself. Authenticates with Amazon ECR (Elastic Container Registry) using AWS CLI commands, retrieving login credentials from the environment variable $AWS_ACCESS_KEY_ID and secret. Creates a simple Dockerfile that copies the built artifacts (build/) to the image and configures Nginx server to serve them. Builds and tags the image with the commit SHA for versioning using $CI_COMMIT_SHA environment variable. Pushes the image to the specified ECR repository. push:\rstage: push\rdependencies:\r- build\rimage: docker:latest\rservices:\r- docker:dind\rscript:\r# Login to ECR using AWS CLI\r- aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws/$ECR_HASH\r# Build and push Docker image\r- echo -e \u0026#34;FROM nginx:alpine\\nCOPY build/ /usr/share/nginx/html\u0026#34; \u0026gt; Dockerfile\r- echo -e \u0026#34;server {\\n\\tlisten 80;\\n\\tlocation / {\\n\\t\\troot /usr/share/nginx/html;\\n\\t\\tindex index.html index.htm;\\n\\t\\ttry_files \\$uri \\$uri/ /index.html;\\n\\t}\\n\\terror_page 404 =200 /index.html;\\n}\u0026#34; \u0026gt; default.conf\r- echo -e \u0026#34;COPY default.conf /etc/nginx/conf.d/default.conf\u0026#34; \u0026gt;\u0026gt; Dockerfile\r- docker build -t \u0026lt;IMAGE_NAME\u0026gt;:$CI_COMMIT_SHA .\r- docker tag \u0026lt;IMAGE_NAME\u0026gt;:$CI_COMMIT_SHA public.ecr.aws/$ECR_HASH/\u0026lt;IMAGE_NAME\u0026gt;:$CI_COMMIT_SHA\r- docker push public.ecr.aws/$ECR_HASH/\u0026lt;IMAGE_NAME\u0026gt;:$CI_COMMIT_SHA Defines a job named deploy in the deploy stage:\nUses AWS CLI to update an ECS (Elastic Container Service) service with a new task definition. This likely deploys the newly built image to the running container instances. Only runs this job when the pipeline is triggered by the prod branch or tag. deploy:\rstage: deploy\rscript:\r- aws ecs update-service --cluster $ECS_CLUSTER_NAME --service $ECS_SERVICE_NAME --task-definition $ECS_TASK_DEFINITION_ARN --desired-count 1 --force-new-deployment\ronly:\r- prod Add project variables Here is some variables need to add: AWS_ACCESS_KEY_ID: Your AWS access key ID for interacting with AWS services.\nAWS_SECRET_ACCESS_KEY: Your AWS secret access key for interacting with AWS services.\nECS_CLUSTER_NAME: The name of your ECS cluster where the service is deployed.\nECS_SERVICE_NAME: The name of the ECS service you want to update.\nECS_TASK_DEFINITION_ARN: The ARN (Amazon Resource Name) of the task definition associated with the service.\nPlease note this names! Later, when we complete creation of AWS resources, we will back to add a value for these variables.\nSteps to add variables: Step 1: Go to your project\u0026rsquo;s Settings \u0026gt; CI/CD \u0026gt; Variables.\nStep 2: Click Add variable and fill in the details.\nCreate GitLab Runner What is GitLab Runner? Think of GitLab Runner as a robot that follows your instructions in your GitLab CI/CD pipelines. It can run tests, build your application, and deploy it to production, all automatically\nIn this workshop, we\u0026rsquo;ll delve into the practical deployment of GitLab Runner on an EC2 instance running Linux\nSteps to create a GitLab Runner: Step 1: Go to your project in GitLab and open the Settings tab.\nStep 2: Under the CI/CD section, expand the Runners section.\nStep 3: Click New project runner.\nStep 4: Select your operating system where you installed the GitLab Runner. Then enter details:\nTags: you can give a tag here, then later you can set to run CI/CD pipeline on only tags you specified. Description (optional): Add a note for future reference. Configuration: Establish rules such as preventing the runner from accepting new jobs, allowing only the protected branch to run the CI/CD pipeline, restricting the use of the current runner to the current project only, and setting a maximum job timeout. Step 5: Click Create runner. This will create a runner for your project.\nPlease note the GITLAB_REGISTRATION_TOKEN (GitLab registration token), you will use this value to connect the GitLab runner from your EC2 instance.\n"
},
{
	"uri": "//localhost:1313/vi/4-mainsettings/4.2-createecrrepository/",
	"title": "Create ECR Repository",
	"tags": [],
	"description": "",
	"content": "Create ECR Repository Step 1. Go to ECR Dashboard Navigate to ECR dashboard at this link: ECR Dashboard. Then click to Get Started.\nStep 2. Choose repository type For easier steps, I will choose Public repository in General settings.\nIf you choosing Private type, you must be authenticate before can pull the image from repository. Just add some line to authenticate with AWS in .gitlab-ci.yml if you want to pull image from private ECR repository.\nStep 3. Enter a unique name for your repository Enter a name for your repository.\nStep 3. Complete creation Click Create repository to complete creation.\nAfter complete creation, you will get repository name and URI. Please note this value, because your need to add this value to variable $ECR_HASH of your GitLab Variables.\n"
},
{
	"uri": "//localhost:1313/vi/4-mainsettings/4.3-defineecstask/",
	"title": "Define ECS Task",
	"tags": [],
	"description": "",
	"content": "Create ECS Task Definition Step 1. Go to ECS Dashboard Navigate to ECS dashboard at this link: ECS Dashboard. Then click to Task definition.\nStep 2. Start to create Task Definition There are 2 options:\nIf you have previous defined task definition, you can use as JSON template.\nI want to create a new Task Definition, so I choose Create new task definition.\nStep 3. Configure infrastructure Now you need to specify some attribute for your task:\nLaunch Type: If you want AWS manage underlying infrastructure for you, choose Fargate. Otherwise, choose EC2 if you want to manage infrastructure by your self.\nOS: You can choose between Linux, or Windows.\nChoose CPU and Memory for your task.\nRole: If you want your ECS Task can interact with other AWS services, then you can specify a Role here, or create a new one.\nStep 4. Link ECS task definition with ECR repository Name: name of container that will run your task, it can be anything.\nImage URI: is the URI of ECR repository you create previously. ex: repo-uri/\u0026lt;IMAGE_NAME\u0026gt;:.\nRemember the values in your .gitlab-ci.yml file? Here is what to use that value, make sure they are same:\n- docker build -t \u0026lt;IMAGE_NAME\u0026gt;:$CI_COMMIT_SHA .\r- docker tag \u0026lt;IMAGE_NAME\u0026gt;:$CI_COMMIT_SHA public.ecr.aws/$ECR_HASH/\u0026lt;IMAGE_NAME\u0026gt;:$CI_COMMIT_SHA\r- docker push public.ecr.aws/$ECR_HASH/\u0026lt;IMAGE_NAME\u0026gt;:$CI_COMMIT_SHA Next, mapping port of your container with port of image will use. In my case, they will be 80 to 80.\nStep 5. Complete creation Click Create to create ECS Task definition.\n"
},
{
	"uri": "//localhost:1313/vi/4-mainsettings/4.4-createecscluster/",
	"title": "Create ECS Cluster",
	"tags": [],
	"description": "",
	"content": "Create ECS Cluster Step 1. Go to ECS Dashboard Navigate to ECS dashboard at this link: ECS Dashboard. Then click to Cluster.\nStep 2. Start to create Cluster Click to Create Cluster button.\nStep 3. Set a name for your cluster Enter a unique name for your cluster.\nStep 4. Choose infrastructure I choose Fargate in this case because I don\u0026rsquo;t want to manage servers. And remember, you choosed Fargate for your Task definition before.\nStep 5. Complete creation Click Create to create ECS cluster.\nCreate ECS Service Step 1: Go to Clusters Click to cluster that you want to create service. Then you will go to cluster detail page.\nStep 2: Start to create service In cluster detail page, scroll down to Services section. Then Click to Create button.\nStep 3: Config service environment I want to create a simple guide for you to start with ECS. So I choose Launch type.\nThe keys differences:\nLaunch type: If development simplicity and cost-effectiveness are your priorities, using a launch type (Fargate or EC2, depending on your preference) might be sufficient.\nCapacity provider strategy: If you need precise resource allocation, advanced scaling, and potentially cost optimization, employing a capacity provider strategy is a better option.\nStep 4: Config for deployment Application type:\nService type is more suitable if you want to host a website.\nTask type is more suitable if you want to run batch job.\nAs I discuss ealier, we will hosting a website by ECS, so Service is a great choice here.\nTask definition:\nChoose the task definition that you have created in previous steps.\nService Name\nGive a unique name for your service.\nStep 5: Choose a number of tasks Enter a number that specify the tasks you want to run.\nStep 6: Configure VPC Choose the VPC you created in prerequisites section, then choose the public subnets to run service.\nStep 6: Configure Security Group (SG) Create a new SG to protect your resource, but still open necessary port to allow user access your website. I open port 80 for my website.\nStep 7: Complete creation Click Create button to create ECS service.\n"
},
{
	"uri": "//localhost:1313/vi/4-mainsettings/4.5-createec2forgitlabrunner/",
	"title": "Create EC2 for GitLab Runner",
	"tags": [],
	"description": "",
	"content": "Create EC2 instance Step 1. Go to EC2 Dashboard Navigate to EC2 dashboard at this link: EC2 Dashboard. Then click to Instances.\nStep 2. Start to create EC2 instance Click Launch instance to create an instance.\nStep 3. Enter a name to instance Enter a unique name for your EC2 instance.\nStep 4: Choose Amazon machine image (AMI) Depend on your usage, and OS, you can choose whatever instance you like. For lower cost, I use Linux, and it offers Amazon Linux 2 for free tier.\nStep 5: Choose instance type I choose t2.micro for my instance type, if you use more CPU and RAM, you need a larger instance type here.\nStep 6: Create key pair If you want to access your instance via local SSH like your local CMD or Powershell, you can create a key here and use later. In my case, I will connect to my instance directly via AWS Console so I choose Proceed without a key pair.\nStep 7: Choose VPC Choose the VPC you created earlier, then using public subnets to help you access instance via its public IP.\nStep 8: Config Security Group To protect your instance, you can restrict access to your instance by SG. Here I allow SSH from anywhere, but you can restrict access to allow SSH from your IP address only.\nStep 9: Add User Data User Data is the script that will run at first time when you instance is starting. I use will it to connect to my GitLab Runner.\nExpand the Advance settings, then scroll down to bottom you will see User Data input box.\nPlease copy this script and paste to you User Data.\nsudo su - root\rcurl -L --output /usr/local/bin/gitlab-runner \u0026#34;https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64\u0026#34;\rchmod +x /usr/local/bin/gitlab-runner\ruseradd --comment \u0026#39;GitLab Runner\u0026#39; --create-home gitlab-runner --shell /bin/bash\rgitlab-runner install --user=\u0026lt;GITLAB_USER_NAME\u0026gt; --working-directory=/home/gitlab-runner\rgitlab-runner start\ryum install -y docker\ryum install -y git\rsystemctl enable docker\rsystemctl start docker\rgitlab-runner register -n --url \u0026lt;GITLAB_URL\u0026gt; --registration-token \u0026lt;GITLAB_REGISTRATION_TOKEN\u0026gt; --executor docker --description \u0026#34;Deployment Runner\u0026#34; --docker-image \u0026#34;docker:stable\u0026#34; --tag-list deployment --docker-privileged\rgitlab-runner run This script sets up a GitLab Runner on a Linux system. It downloads the runner software, creates a dedicated user for it, and configures it to use Docker to run jobs from your GitLab server.\nStep 10: Complete creation Click Launch instance to start your EC2 instance.\n"
},
{
	"uri": "//localhost:1313/vi/4-mainsettings/4.6-connectec2withgitlabrunner/",
	"title": "Connect EC2 with GitLab Runner",
	"tags": [],
	"description": "",
	"content": "Your instance look good but in build phase, but in push phase maybe you will get this error:\nERROR: Cannot connect to the Docker daemon at tcp://docker:2375. Is the docker daemon running?\rERROR: Job failed: exit code 1 Look back our push phase:\npush:\rstage: push\rdependencies:\r- build\rimage: docker:latest\rservices:\r- docker:dind\rscript:\r# Login to ECR using AWS CLI\r- aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws/$ECR_HASH\r# Build and push Docker image\r- echo -e \u0026#34;FROM nginx:alpine\\nCOPY build/ /usr/share/nginx/html\u0026#34; \u0026gt; Dockerfile\r- echo -e \u0026#34;server {\\n\\tlisten 80;\\n\\tlocation / {\\n\\t\\troot /usr/share/nginx/html;\\n\\t\\tindex index.html index.htm;\\n\\t\\ttry_files \\$uri \\$uri/ /index.html;\\n\\t}\\n\\terror_page 404 =200 /index.html;\\n}\u0026#34; \u0026gt; default.conf\r- echo -e \u0026#34;COPY default.conf /etc/nginx/conf.d/default.conf\u0026#34; \u0026gt;\u0026gt; Dockerfile\r- docker build -t \u0026lt;IMAGE_NAME\u0026gt;:$CI_COMMIT_SHA .\r- docker tag \u0026lt;IMAGE_NAME\u0026gt;:$CI_COMMIT_SHA public.ecr.aws/$ECR_HASH/\u0026lt;IMAGE_NAME\u0026gt;:$CI_COMMIT_SHA\r- docker push public.ecr.aws/$ECR_HASH/\u0026lt;IMAGE_NAME\u0026gt;:$CI_COMMIT_SHA Problem due to the push phase might encounter an error due to a potential incompatibility between the Docker image used for running tasks (docker:latest) and the Docker image being built, tagged, and pushed (nginx:alpine ).\nBecause the two Docker images might not share the necessary Docker environment for building and pushing images.\nThe solution is mount the volumes of the two Docker images together to ensure they share a consistent Docker environment.\nStep 1: Go to Instances In EC2 dashboard, click Instances in left sidebar to go to instance page.\nStep 2: Connect to EC2 instance Select the instance you want to connect, then click Connect button.\nStep 3: Choose intance connect type I will use EC2 instance connect via AWS console. Then click Connect to continue.\nNow you can see the Linux terminal\nStep 4: Mount docker volume To mount docker volume, enter following scripts:\nsudo su - root\rsudo nano /etc/gitlab-runner/config.toml Scroll down and find the line of volume, then add /var/run/docker.sock:/var/run/docker.sock in the array. It will look like this:\nStep 5: Check GitLab Runner status Back to your GitLab project and check if the GitLab runner status is running.\nOkay, now you completed all setup. Now let see our result!\n"
},
{
	"uri": "//localhost:1313/vi/4-mainsettings/4.7-result/",
	"title": "Result",
	"tags": [],
	"description": "",
	"content": "Result Check if your GiLab pipeline complete in both 3 phase Check if your Cluster static is active, and service is active Check if your website is deployed You can go to task detail page, find the public IP address that given to your task.\n"
},
{
	"uri": "//localhost:1313/vi/5-cleanup/",
	"title": "Clean Up Resources",
	"tags": [],
	"description": "",
	"content": "Here is some service need to cleanup Delete EC2 instance (Instance connect to your GitLab Runner) Back to EC2 Dashboard, go to Instances from left sidebar and delete.\nDelete ECR repository Back to ECR Dashboard, go to Repositories from left sidebar and delete.\nDelete ECS Cluster Back to ECS Dashboard, delete your task and service first, then delete your cluster.\nDelete ECS Task definition Back to ECS Dashboard, go to Task definition from left sidebar and delete.\nDelete NAT Gateway Back to your VPC, go to NAT Gateway from left sidebar and delete.\nDelete S3 Endpoint Back to your VPC, go to Endpoints from left sidebar and delete.\nDelete Elastic IP Back to your VPC, go to Elastic IPs from left sidebar and delete.\nDelete Elstic Network Interface (ENI) Back to EC2 Dashboard, go to Network Interface and delete.\nDelete VPC Back to your VPC, select the VPC you want to delete and delete.\nüéâ Everything is done. Hope you have a good experience with this workshop!\n"
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]